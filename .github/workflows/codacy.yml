# Codacy Security Scan -> Split SARIF runs (hardened, pinned, least-privilege)
# =============================================================================
# What this workflow does (high level):
#   1) Checks out your code with read-only permissions and no persisted credentials.
#   2) Runs Codacy Analysis CLI (via pinned release) to generate SARIF results.
#   3) Splits multi-run SARIF into single-run SARIF files (one per analyzer).
#   4) Uploads each single-run SARIF to GitHub Code Scanning with a unique category.
#   5) Stores the split SARIFs as a build artifact for auditing.
#
# Why we split:
#   - GitHub Code Scanning accepts one SARIF "run" per upload+category.
#     Codacy often outputs multiple runs in a single SARIF (one per tool).
#     Splitting ensures every upload contains exactly one run, avoiding rejections.
#
# Best practices implemented:
#   - Default-deny permissions at the workflow level; jobs elevate only what they need.
#   - Third-party actions pinned to commit SHAs (reproducible, tamper-resistant).
#   - Use pull_request (not pull_request_target) to guard untrusted forks.
#   - Concurrency cancels superseded runs to prevent CI pile-ups.
#   - Timeouts cap spend and fail fast.
#   - Harden egress with StepSecurity.
#   - Scoped checkout credentials (no pushes from this workflow).
#   - Explicit runner (ubuntu-24.04) for reproducibility.
#   - Results are auditable (artifact with retention).
#
# Tuning notes:
#   - Narrow the 'paths:' filters below to save CI minutes.
#   - Decide gating: keep informational (continue-on-error) or fail PRs on findings.

name: Codacy Security Scan

on:
  pull_request:
    branches: [ "**" ]
    paths:
      - "**/*"
      - ".github/workflows/codacy.yml"
  push:
    branches: [ "**" ]
    paths:
      - "**/*"
      - ".github/workflows/codacy.yml"
  schedule:
    - cron: "16 7 * * 2"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read

defaults:
  run:
    shell: bash -Eeuo pipefail {0}

jobs:
  # ────────────────────────────── Job 1: Scan + Split + Validate ──────────────────────────────
  codacy-scan:
    name: Codacy scan → split → validate SARIF
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    permissions:
      contents: read
      actions: read

    # Expose the FINAL, validated list of files to the next job.
    outputs:
      sarif_files: ${{ steps.validate.outputs.sarif_files_valid }}

    env:
      SARIF_OUT: results.sarif  # initial Codacy SARIF path

    steps:
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      # Install Codacy CLI v2 from a pinned release asset.
      - name: Install Codacy CLI v2 (pinned)
        run: |
          VER="1.0.0-main.356.sha.ee1b0e6"
          curl -fsSL -o /tmp/ccli.tgz \
            "https://github.com/codacy/codacy-cli-v2/releases/download/${VER}/codacy-cli-v2_${VER}_linux_amd64.tar.gz"
          sudo tar -xzf /tmp/ccli.tgz -C /usr/local/bin codacy-cli-v2
          sudo mv /usr/local/bin/codacy-cli-v2 /usr/local/bin/codacy-cli
          codacy-cli version

      - name: Resolve repository coordinates for Codacy
        id: coords
        run: |
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"
          echo "owner=${OWNER}" >> "$GITHUB_OUTPUT"
          echo "repo=${REPO}"   >> "$GITHUB_OUTPUT"

      - name: Codacy CLI v2 init (remote if token present; else local)
        env:
          CODACY_API_TOKEN: ${{ secrets.CODACY_API_TOKEN }}
        run: |
          if [[ -n "${CODACY_API_TOKEN:-}" ]]; then
            codacy-cli init \
              --api-token "$CODACY_API_TOKEN" \
              --provider gh \
              --organization "${{ steps.coords.outputs.owner }}" \
              --repository   "${{ steps.coords.outputs.repo }}"
          else
            echo "CODACY_API_TOKEN not set; using local defaults."
            codacy-cli init
          fi

      - name: Codacy CLI v2 install toolchains
        run: codacy-cli install

      - name: Run Codacy Analysis CLI → SARIF
        continue-on-error: true
        env:
          SARIF_OUT: ${{ env.SARIF_OUT }}
        run: |
          codacy-cli analyze --format sarif -o "${SARIF_OUT}"

      - name: Inspect SARIF (runs/results summary)
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq >/dev/null
          BYTES=$(wc -c < "${SARIF_OUT}" || echo 0)
          echo "SARIF size (bytes): ${BYTES}"
          if [[ "${BYTES}" -gt 0 ]]; then
            echo -e "Runs\tTool\tResults"
            jq -r '(.runs // []) | to_entries[] | "\(.key+1)\t\(.value.tool.driver.name // "unknown")\t\((.value.results|length))"' "${SARIF_OUT}" || true
          fi

      # Split multi-run SARIF → single-run files (preserve the run; normalize missing fields only).
      - name: Split SARIF into single-run files
        id: split
        run: |
          mkdir -p reports
          if [[ ! -s "${SARIF_OUT}" ]]; then
            echo "sarif_files=[]" >> "$GITHUB_OUTPUT"
            echo "No SARIF produced; skipping split."
            exit 0
          fi

          python - <<'PY'
          import json, os, re, pathlib, hashlib, copy
          sarif_path = os.environ.get("SARIF_OUT", "results.sarif")
          outdir = pathlib.Path("reports"); outdir.mkdir(parents=True, exist_ok=True)

          with open(sarif_path, "r", encoding="utf-8") as f:
              data = json.load(f)

          version = data.get("version", "2.1.0")
          schema  = data.get("$schema", "https://json.schemastore.org/sarif-2.1.0.json")

          files = []
          runs = data.get("runs", [])
          for i, original_run in enumerate(runs, 1):
              run = copy.deepcopy(original_run)

              # Normalize only if missing
              tool   = run.get("tool") or {}
              driver = tool.get("driver") or {}
              name   = driver.get("name") or f"run{i}"
              driver["name"] = name
              if driver.get("rules") is None:
                  driver["rules"] = []
              if run.get("results") is None:
                  run["results"] = []
              tool["driver"] = driver
              run["tool"] = tool

              out_doc = {"version": version, "$schema": schema, "runs": [run]}

              slug = re.sub(r"[^A-Za-z0-9._-]+", "-", name).strip("-").lower() or f"run{i}"
              sh = hashlib.sha1(name.encode("utf-8")).hexdigest()[:8]
              category = f"codacy-{slug}-{i}-{sh}"

              outfile = outdir / f"{category}.sarif"
              with open(outfile, "w", encoding="utf-8") as wf:
                  json.dump(out_doc, wf, ensure_ascii=False)

              files.append({"file": str(outfile), "category": category})

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as go:
              go.write("sarif_files=" + json.dumps(files) + "\n")
          PY

      # VALIDATE and minimally REPAIR the split SARIF files.
      # - Downloads the SARIF 2.1.0 schema, validates each file.
      # - Repairs missing: version, $schema, tool.driver.name, rules[], results[].
      # - Emits a filtered list of VALID files (preserving original categories).
      - name: Validate and repair split SARIFs
        id: validate
        env:
          SPLIT_JSON: ${{ steps.split.outputs.sarif_files }}
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq >/dev/null
          python - <<'PY'
          import json, os, pathlib, urllib.request, sys
          from jsonschema import Draft202012Validator

          split = json.loads(os.environ.get("SPLIT_JSON","[]"))
          out_valid = []
          invalid = []

          schema_url = "https://json.schemastore.org/sarif-2.1.0.json"
          schema_path = pathlib.Path("sarif-2.1.0.json")
          with urllib.request.urlopen(schema_url) as r:
            schema_path.write_bytes(r.read())
          schema = json.loads(schema_path.read_text("utf-8"))
          validator = Draft202012Validator(schema)

          def repair(doc):
            # Minimal, safe defaults only
            if doc.get("version") != "2.1.0":
              doc["version"] = "2.1.0"
            if "$schema" not in doc or not isinstance(doc["$schema"], str):
              doc["$schema"] = "https://json.schemastore.org/sarif-2.1.0.json"
            runs = doc.get("runs")
            if not isinstance(runs, list) or len(runs) == 0:
              doc["runs"] = [{"tool": {"driver": {"name": "unknown"}},"results": []}]
              return
            run = runs[0]
            tool = run.get("tool") or {}
            driver = tool.get("driver") or {}
            if not isinstance(driver.get("name"), str) or not driver["name"]:
              driver["name"] = "unknown"
            if driver.get("rules") is None:
              driver["rules"] = []
            if run.get("results") is None or not isinstance(run.get("results"), list):
              run["results"] = []
            tool["driver"] = driver
            run["tool"] = tool
            doc["runs"][0] = run

          for item in split:
            path = pathlib.Path(item["file"])
            try:
              doc = json.loads(path.read_text("utf-8"))
            except Exception as e:
              invalid.append((str(path), f"read/parse error: {e}")); continue

            # Try as-is
            errors = sorted(validator.iter_errors(doc), key=lambda e: e.path)
            if errors:
              # Attempt minimal repair and re-validate
              repair(doc)
              errors = sorted(validator.iter_errors(doc), key=lambda e: e.path)
              if errors:
                invalid.append((str(path), f"{len(errors)} schema error(s)"))
                continue
              # Write repaired doc back
              path.write_text(json.dumps(doc, ensure_ascii=False), encoding="utf-8")

            out_valid.append(item)

          # Emit outputs
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as go:
            go.write("sarif_files_valid="+json.dumps(out_valid)+"\n")

          print(f"VALID: {len(out_valid)} file(s)")
          if invalid:
            print("INVALID (skipped):")
            for p, why in invalid:
              print(f" - {p}: {why}")
          PY

      - name: Upload split (and fixed) SARIFs as artifact
        if: always() && hashFiles('reports/*.sarif') != ''
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: codacy-sarif-split
          path: reports/*.sarif
          retention-days: 14

  # ───────────────────────────── Job 2: Upload per-run SARIF ─────────────────────────────
  upload-to-code-scanning:
    name: Upload single-run SARIFs
    needs: codacy-scan
    if: ${{ needs.codacy-scan.outputs.sarif_files != '' && needs.codacy-scan.outputs.sarif_files != '[]' }}
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write
      actions: read

    strategy:
      fail-fast: false
      matrix:
        item: ${{ fromJson(needs.codacy-scan.outputs.sarif_files) }}
        # {"file":"reports/<category>.sarif","category":"codacy-<tool>-<i>-<hash>"}

    steps:
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Download split SARIFs
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: codacy-sarif-split
          path: reports

      - name: List split SARIFs (debug)
        run: |
          ls -lh reports || true
          if command -v jq >/dev/null 2>&1; then
            for f in reports/*.sarif; do
              echo "---- $f"
              jq -r '[.runs[0].tool.driver.name, (.runs[0].results|length)] | @tsv' "$f" || true
            done
          fi

      - name: Upload SARIF (single run)
        uses: github/codeql-action/upload-sarif@192325c86100d080feab897ff886c34abd4c83a3 # v3.30.3
        with:
          sarif_file: ${{ matrix.item.file }}
          category:   ${{ matrix.item.category }}
